---
title: Navigation
description: Navigation architecture and patterns for the White Label App.
---

import { Aside } from '@astrojs/starlight/components';

## Overview

TODO: Document overall navigation architecture.

## Static Navigation API

TODO: Document use of React Navigation's static API with `createStaticNavigation`.

## Auth-Gated Screens

TODO: Document conditional screen groups with `if: useIsAuthenticated`.

## Deep Linking

The app supports deep links for navigating directly to specific screens. Deep links work differently depending on whether the user is authenticated.

### The Problem

When a user taps a deep link (e.g., from a push notification) while logged out:

1. The app opens to the Login screen (correct behavior)
2. React Navigation tries to navigate to the deep link target
3. Navigation fails because authenticated screens don't exist yet
4. User logs in but lands on the default screen, losing their intended destination

### Solution: Deferred Deep Links

We use a custom `DeepLinkProvider` that intercepts deep links and stores them when the user is not authenticated. After login, the stored URL is replayed.

```tsx
// In App.tsx
<DeepLinkProvider isAuthenticated={isAuthenticated} prefixes={['myapp://']}>
  <Navigation linking={useLinkingConfig()} />
</DeepLinkProvider>
```

The provider works by:
1. Providing custom `getInitialURL` and `subscribe` functions to React Navigation's linking config
2. When unauthenticated: storing the URL and returning `null` to prevent navigation
3. When authenticated: passing URLs through normally
4. After login: the stored URL is replayed via manual navigation

<Aside type="note" title="Why not UNSTABLE_routeNamesChangeBehavior?">
React Navigation has a built-in option `UNSTABLE_routeNamesChangeBehavior: 'lastUnhandled'` that's supposed to handle this automatically. However, it doesn't work with the static API + conditional groups pattern (`createStaticNavigation` with `if:` groups). We tested this and deep links were not replayed after authentication.
</Aside>

### Replay Logic

After authentication, a `useEffect` watches for the auth state change and replays the pending URL:

```tsx
useEffect(() => {
  const justAuthenticated = isAuthenticated && !wasAuthenticated.current;

  if (justAuthenticated && pendingUrl) {
    const url = consumePendingUrl();
    // Small delay to ensure navigation state has updated
    setTimeout(() => {
      navigationRef.current.navigate(parseUrl(url));
    }, 500);
  }
}, [isAuthenticated]);
```

## Async Routing with Router Screens

Sometimes you need to make an async decision (API call, feature flag check, etc.) before knowing which screen to show. Two factory functions enable this pattern.

### The Problem

React Navigation's `navigate()` is synchronous. If you need to:
- Call an API to determine eligibility
- Check a feature flag
- Load user preferences

...you'd typically do this in the calling screen, which couples business logic to the wrong location.

### Solution: Router Screens

A router screen is a transparent overlay that:
1. Appears instantly (no animation)
2. Shows a loading spinner
3. Runs your async decision logic
4. Calls `replace()` to the actual destination

### Creating a Router (Promise-based)

For most cases, use `createRouterScreen` with an async function. This is simpler and handles loading state, cleanup, and error handling automatically.

```tsx
// Simple async function - factory handles the rest
const CheckoutRouter = createRouterScreen(async ({ cartId }: { cartId: string }) => {
  const eligibility = await checkEligibility(cartId);
  return {
    destination: eligibility.approved ? 'CheckoutForm' : 'CheckoutBlocked',
    destinationParams: { cartId },
  };
});
```

**With custom error messages** - throw an Error with your message:

```tsx
async function fetchGasMapType(): Promise<'A' | 'B'> {
  const response = await api.getGasStations();

  if (!response.ok) {
    throw new Error('Unable to load gas stations. Please check your connection.');
  }

  return response.data.type;
}

const GasMapRouter = createRouterScreen(async () => {
  const type = await fetchGasMapType();
  return { destination: type === 'A' ? 'GasMapA' : 'GasMapB' };
});
```

### Creating a Router (Hook-based)

Use `createRouterScreenFromHook` when you need access to React context or complex state logic:

```tsx
function useCheckoutDecision(params: { cartId: string }) {
  // Can use hooks here!
  const { user } = useAuth();
  const isNewCheckoutEnabled = useFeatureFlag('new-checkout');

  const [state, setState] = useState({
    isLoading: true,
    destination: '',
    destinationParams: {}
  });

  useEffect(() => {
    let cancelled = false;

    async function decide() {
      const eligibility = await checkEligibility(params.cartId, user.id);
      if (cancelled) return;

      setState({
        isLoading: false,
        destination: eligibility.approved
          ? (isNewCheckoutEnabled ? 'CheckoutFormV2' : 'CheckoutForm')
          : 'CheckoutBlocked',
        destinationParams: { cartId: params.cartId },
      });
    }
    decide();

    return () => { cancelled = true; };
  }, [params.cartId, user.id, isNewCheckoutEnabled]);

  return state;
}

const CheckoutRouter = createRouterScreenFromHook(useCheckoutDecision);
```

<Aside type="tip" title="When to use each approach">
| Approach | Use When |
|----------|----------|
| `createRouterScreen` (promise) | Simple API calls, no React context needed |
| `createRouterScreenFromHook` | Need `useAuth()`, `useFeatureFlag()`, or other hooks |
</Aside>

### Register in your stack

Use the attached `screenOptions`:

```tsx
const MyStack = createNativeStackNavigator({
  screens: {
    // Entry point - transparent overlay, no animation
    Checkout: {
      screen: CheckoutRouter,
      options: CheckoutRouter.screenOptions,
    },
    // Destinations - normal screens
    CheckoutForm: {
      screen: CheckoutFormScreen,
      options: { title: 'Checkout' },
    },
    CheckoutBlocked: {
      screen: CheckoutBlockedScreen,
      options: { title: 'Not Available' },
    },
  },
});
```

### Screen Options

The factory attaches recommended options as a static property:

```tsx
Screen.screenOptions = {
  presentation: 'transparentModal',  // Overlay, don't push
  headerShown: false,                // No header during loading
  animation: 'none',                 // Appear instantly
};
```

This ensures the router overlays the current screen transparently, then the destination animates in normally (modal slide-up or stack push).

### Works for Both Modals and Stack Pushes

The pattern works identically whether your destination is:
- A modal (`presentation: 'modal'`)
- A regular stack screen (default push animation)

The router is always a transparent overlay; only the destination's presentation matters.

<Aside type="tip" title="Keep Decision Logic Co-located">
Define the `useDecision` hook near the feature it serves. This keeps async routing logic with the feature rather than scattered across calling screens.
</Aside>

### Error Handling

Both factories display an alert when an error occurs, then navigate back.

**Promise-based:** Throw an Error with your custom message:

```tsx
const MyRouter = createRouterScreen(async (params) => {
  const result = await api.checkEligibility(params.id);

  if (!result.ok) {
    throw new Error('Unable to process your request. Please try again.');
  }

  return { destination: result.screen };
});
```

**Hook-based:** Return an `error` field:

```tsx
function useMyDecision(params) {
  const [state, setState] = useState({ isLoading: true, destination: '' });

  useEffect(() => {
    async function decide() {
      try {
        const result = await api.checkEligibility(params.id);
        setState({ isLoading: false, destination: result.screen });
      } catch (err) {
        setState({
          isLoading: false,
          destination: '',
          error: 'Unable to process your request. Please try again.',
        });
      }
    }
    decide();
  }, [params.id]);

  return state;
}
```

**Behavior:**

| Scenario | Result |
|----------|--------|
| Success with destination | Navigates to destination screen |
| Error thrown / error field set | Alert with message, OK → goBack |

<Aside type="note" title="Custom Error Screens">
For full control over the error experience (custom UI, retry logic, etc.), catch the error and return a destination to your own error screen instead of throwing/returning an error.
</Aside>

### Caveats

#### Router and Destinations Must Be Siblings

`replace()` only works for screens in the **same navigator**. The router and all its possible destinations must be defined as siblings in the same stack:

```tsx
// ✅ Works - all in same stack
const MyStack = createNativeStackNavigator({
  screens: {
    CheckoutRouter: { screen: CheckoutRouter, options: CheckoutRouter.screenOptions },
    CheckoutForm: { screen: CheckoutFormScreen },
    CheckoutBlocked: { screen: CheckoutBlockedScreen },
  },
});

// ❌ Won't work - destination in different navigator
const StackA = createNativeStackNavigator({
  screens: { CheckoutRouter: { ... } },
});
const StackB = createNativeStackNavigator({
  screens: { CheckoutForm: { ... } },  // replace() can't reach this
});
```

#### Deep Links Bypass the Router

If a user deep links directly to a destination (e.g., `/checkout-form`), it bypasses the router entirely. Depending on your use case, this could be:
- **Desired** - user already has the context/permissions
- **Problematic** - user skips required validation

Consider whether destination screens should handle being accessed directly.

#### Cleanup Async Work on Unmount (Hook-based only)

If the user dismisses the router (swipe back, hardware back) while loading, your async logic may still complete and attempt to navigate.

The **promise-based** factory handles this automatically. For **hook-based** routers, handle cleanup manually:

```tsx
useEffect(() => {
  let cancelled = false;

  async function decide() {
    const result = await fetchEligibility();
    if (!cancelled) {
      setState({ isLoading: false, destination: result.screen });
    }
  }
  decide();

  return () => { cancelled = true; };
}, []);
```

#### Params Must Be Serializable

`destinationParams` passes through React Navigation's state, so values must be serializable. No functions, class instances, or circular references.

```tsx
// ✅ Good
{ destinationParams: { userId: '123', amount: 99.99 } }

// ❌ Bad
{ destinationParams: { onComplete: () => {}, user: new User() } }
```

## Tab Navigation

TODO: Document bottom tab structure.

## Modal Presentation

TODO: Document root-level modals.
